import{s as e,l as n,a as o,b as t,r,t as a,c as s}from"./vendor.69abf69f.js";!function(e=".",n="__import__"){try{self[n]=new Function("u","return import(u)")}catch(o){const t=new URL(e,location),r=e=>{URL.revokeObjectURL(e.src),e.remove()};self[n]=e=>new Promise(((o,a)=>{const s=new URL(e,t);if(self[n].moduleMap[s])return o(self[n].moduleMap[s]);const i=new Blob([`import * as m from '${s}';`,`${n}.moduleMap['${s}']=m;`],{type:"text/javascript"}),c=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(i),onerror(){a(new Error(`Failed to import: ${e}`)),r(c)},onload(){o(self[n].moduleMap[s]),r(c)}});document.head.appendChild(c)})),self[n].moduleMap={}}}("/graphics-workshop/assets/");var i="precision mediump float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform float seed;\n\nvoid main() {\n    vec2 coord = gl_FragCoord.xy / resolution;\n\n    // Output RGB color in range from 0.0 to 1.0\n    vec3 color = vec3(coord.x, coord.y, 0.0);\n    color.z += abs(sin(time));\n\n    // 1. Uncomment these lines to draw triangles\n    // vec2 squareCoord = 20.0 * gl_FragCoord.xy / resolution.y + vec2(time);\n    // vec2 loc = fract(squareCoord);\n    // color = vec3(smoothstep(-0.05, 0.05, loc.y - loc.x));\n\n    // 2. Uncomment these lines to invert some of the triangles\n    // vec2 cell = squareCoord - loc;\n    // if (mod(2.0 * cell.x + cell.y, 5.0) == 1.0) {\n    //     color = 1.0 - color;\n    // }\n\n    // 3. Uncomment these lines to produce interesting colors\n    // float c = mod(3.0 * cell.x + 2.0 * cell.y, 7.0) / 7.0;\n    // color = 1.0 - (1.0 - color) * vec3(c, c, c);\n\n    // 4. Uncomment to lighten the colors\n    // color = sqrt(color);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n",c="attribute vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n";const l=r(),m=function(r,{eye:a,center:s}){let i=!1,c=null;const l={eye:a,center:s},m=e=>{i=!0,c=[e.screenX/r.height,e.screenY/r.height]},d=a=>{if(!i)return;const[s,m]=[a.screenX/r.height,a.screenY/r.height],[d,u]=c;c=[s,m];const v=e([],l.eye,l.center),p=n(v);let h=Math.acos(v[1]/p),f=Math.atan2(v[2],v[0]);h=Math.min(Math.max(h-5*(m-u),1e-8),Math.PI-1e-8),f+=5*(s-d),o(l.eye,p*Math.cos(f)*Math.sin(h),p*Math.cos(h),p*Math.sin(f)*Math.sin(h)),t(l.eye,l.eye,l.center)},u=()=>{i=!1};return r.addEventListener("mousedown",m),r.addEventListener("mousemove",d),r.addEventListener("mouseup",u),r.addEventListener("touchstart",(e=>m(e.touches[0]))),r.addEventListener("touchmove",(e=>d(e.touches[0]))),r.addEventListener("touchend",u),l}(document.getElementsByTagName("canvas")[0],{eye:[1.7,1.5,2.9],center:[0,0,0]}),d=function(){const e=new a({title:"Controls"}),n={project:"quilt",seed:0,scale:20,mesh:"...",fps:0};e.addInput(n,"project",{options:{"Quilt patterns":"quilt","Procedural landscapes":"landscape","Rasterization and shading":"shading","Contour sketching":"contours","Ray tracing":"raytracing"}});const o=[[e.addInput(n,"seed",{min:0,max:1}),["quilt","landscape"]],[e.addInput(n,"scale",{min:10,max:30}),["landscape"]],[e.addInput(n,"mesh",{options:{"Stanford Bunny":"...","Utah Teapot":"...1","Trefoil Knot":"...2",Dragon:"...3",Suzanne:"...4"}}),["shading","contours"]]];e.addMonitor(n,"fps"),e.addSeparator(),e.addButton({title:"Instructions"}).on("click",(()=>{const e=document.createElement("a");e.href="https://github.com/ekzhang/graphics-workshop#readme",e.target="_blank",e.click()}));const t=localStorage.getItem("graphics-workshop");if(t)try{e.importPreset(JSON.parse(t))}catch(s){console.warn(`Error loading saved preset: ${s}`)}const r=()=>{const t=e.exportPreset();localStorage.setItem("graphics-workshop",JSON.stringify(t));for(const[e,r]of o)e.hidden=!r.includes(n.project)};return r(),e.on("change",r),n}();const u=l({attributes:{position:[[-1,1],[-1,-1],[1,1],[1,-1]]},elements:[[0,1,2],[2,1,3]],uniforms:{view:()=>s([],m.eye,m.center,[0,1,0]),resolution:({drawingBufferWidth:e,drawingBufferHeight:n})=>[e,n],time:l.context("time")}}),v={quilt:l({frag:i,vert:c,uniforms:{seed:()=>d.seed}}),landscape:l({frag:'precision mediump float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform float seed;\nuniform float scale;\n\nfloat snoise(vec2);\n\nvoid main() {\n    vec2 coord = (2.0 * gl_FragCoord.xy - resolution) / resolution.y;\n    coord *= scale;\n\n    // "Organic" simplex noise values in range [-1, 1]\n    float noise1 = snoise(vec2(seed * 10000.0, 0) + coord);\n    float noise2 = snoise(vec2(seed * 10000.0, 1e3) + coord / 2.0);\n    float noise4 = snoise(vec2(seed * 10000.0, 2e3) + coord / 4.0);\n    float noise8 = snoise(vec2(seed * 10000.0, 3e3) + coord / 8.0);\n\n    // Display various scales of simplex noise\n    vec3 color = 0.5 + 0.5 * vec3(noise1, noise2, noise8);\n\n    // 1. Fractal noise scales: uncomment each line, one at a time\n    // color = vec3(0.5);\n    // color += 0.5 * noise8;\n    // color += 0.25 * noise4;\n    // color += 0.1 * noise2;\n    // color += 0.05 * noise1;\n\n    // 2. Generate "water" and "land"\n    // float elevation = 0.3 - 0.2 * max(length(coord) - 20.0, 0.0);\n    // elevation += noise8 + noise4 * 0.2 + noise2 * 0.1 + noise1 * 0.05;\n    // float landFactor = smoothstep(-0.05, 0.05, elevation);\n    // float deepSea = smoothstep(-0.1, -0.3, elevation);\n    // float deepColor = 0.8 - 0.3 * smoothstep(-0.2, -0.5, elevation);\n    // vec3 waterColor = mix(vec3(0.2, 0.2, 0.8), vec3(0.0, 0.0, deepColor), deepSea);\n    // color = mix(waterColor, vec3(0.0, 0.6, 0.0), landFactor);\n\n    // 3. Generate "mountains" and "beaches" based on elevation\n    // float mountainFactor = (elevation - 1.0) * 5.0;\n    // vec3 mountainColor = vec3(0.12, 0.15, 0.1);\n    // mountainColor = mix(mountainColor, vec3(0.4, 0.32, 0.4), smoothstep(0.7, 0.8, mountainFactor));\n    // mountainColor = mix(mountainColor, vec3(0.9, 0.9, 0.9), smoothstep(1.1, 1.15, mountainFactor));\n    // vec3 landColor = mix(vec3(0.0, 0.6, 0.0), mountainColor, smoothstep(0.0, 0.1, mountainFactor));\n    // float grassFactor = smoothstep(0.75, 0.7, elevation);\n    // landColor = mix(landColor, vec3(0.2, 0.8, 0.0), grassFactor);\n    // float beachFactor = smoothstep(0.5, 0.4, elevation);\n    // landColor = mix(landColor, vec3(0.9, 0.9, 0.5), beachFactor);\n    // color = mix(waterColor, landColor, landFactor);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n\n\n\n//\n// Everything below this line is an implementation of 2D simplex\n// noise in GLSL. You shouldn\'t modify any code below.\n//\n// If you\'re curious, see the following paper:\n// https://weber.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n//\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n',vert:"attribute vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n",uniforms:{seed:()=>d.seed,scale:()=>d.scale}}),shading:l({frag:i,vert:c}),contours:l({frag:i,vert:c}),raytracing:l({frag:i,vert:c})},p=[...Array(60)].fill(0);l.frame((()=>{const e=p.shift(),n=performance.now();p.push(n),0!==e&&(d.fps=1e3/((n-e)/p.length)),u((()=>{l.clear({color:[0,0,0,1]}),v[d.project](),performance.now()}))}));
