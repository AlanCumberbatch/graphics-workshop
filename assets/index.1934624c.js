import{s as n,l as e,a as o,b as t,r as i,t as r,c as s,p as a}from"./vendor.7e6f1bd5.js";!function(n=".",e="__import__"){try{self[e]=new Function("u","return import(u)")}catch(o){const t=new URL(n,location),i=n=>{URL.revokeObjectURL(n.src),n.remove()};self[e]=n=>new Promise(((o,r)=>{const s=new URL(n,t);if(self[e].moduleMap[s])return o(self[e].moduleMap[s]);const a=new Blob([`import * as m from '${s}';`,`${e}.moduleMap['${s}']=m;`],{type:"text/javascript"}),c=Object.assign(document.createElement("script"),{type:"module",src:URL.createObjectURL(a),onerror(){r(new Error(`Failed to import: ${n}`)),i(c)},onload(){o(self[e].moduleMap[s]),i(c)}});document.head.appendChild(c)})),self[e].moduleMap={}}}("/graphics-workshop/assets/");var c="/graphics-workshop/assets/teapot.obj.40bf042c.json";const l=i({extensions:["OES_standard_derivatives"]}),m=function(i,{eye:r,center:s}){let a=!1,c=null;const l={eye:r,center:s},m=n=>{a=!0,c=[n.screenX/i.height,n.screenY/i.height]},d=r=>{if(!a)return;const[s,m]=[r.screenX/i.height,r.screenY/i.height],[d,v]=c;c=[s,m];const u=n([],l.eye,l.center),f=e(u);let p=Math.acos(u[1]/f),h=Math.atan2(u[2],u[0]);p=Math.min(Math.max(p-5*(m-v),1e-8),Math.PI-1e-8),h+=5*(s-d),o(l.eye,f*Math.cos(h)*Math.sin(p),f*Math.cos(p),f*Math.sin(h)*Math.sin(p)),t(l.eye,l.eye,l.center)},v=()=>{a=!1};return i.addEventListener("mousedown",m),i.addEventListener("mousemove",d),i.addEventListener("mouseup",v),i.addEventListener("touchstart",(n=>m(n.touches[0]))),i.addEventListener("touchmove",(n=>d(n.touches[0]))),i.addEventListener("touchend",v),l}(document.getElementsByTagName("canvas")[0],{eye:[1,0,5.2],center:[0,0,0]}),d=function(){const n=new r({title:"Controls"}),e={project:"quilt",seed:0,scale:20,mesh:c,fps:0,kd:{r:95,g:230,b:213},ks:{r:240,g:240,b:240},shininess:5};n.addInput(e,"project",{options:{"Quilt patterns":"quilt","Procedural landscapes":"landscape","Rasterization and shading":"shading","Stylized rendering":"contours","Ray tracing":"raytracing"}});const o=[[n.addInput(e,"seed",{min:0,max:1}),["quilt","landscape"]],[n.addInput(e,"scale",{min:10,max:30}),["landscape"]],[n.addInput(e,"mesh",{options:{Gengar:"/graphics-workshop/assets/gengar.obj.372efedb.json",Knot:"/graphics-workshop/assets/knot.obj.937920cf.json",Sphere:"/graphics-workshop/assets/sphere.obj.4e2aaece.json",Suzanne:"/graphics-workshop/assets/suzanne.obj.c35b0f43.json",Teapot:c}}).on("change",(n=>u(n.value))),["shading","contours"]],[n.addInput(e,"kd"),["shading","contours"]],[n.addInput(e,"ks"),["shading","contours"]],[n.addInput(e,"shininess",{min:1,max:9}),["shading","contours"]]];n.addMonitor(e,"fps"),n.addSeparator(),n.addButton({title:"Instructions"}).on("click",(()=>{const n=document.createElement("a");n.href="https://github.com/ekzhang/graphics-workshop#readme",n.target="_blank",n.click()}));const t=localStorage.getItem("graphics-workshop");if(t)try{n.importPreset(JSON.parse(t))}catch(s){console.warn(`Error loading saved preset: ${s}`)}const i=()=>{const t=n.exportPreset();localStorage.setItem("graphics-workshop",JSON.stringify(t));for(const[n,i]of o)n.hidden=!i.includes(e.project)};return i(),n.on("change",i),e}();let v=null;async function u(n){const e=await fetch(n);v=await e.json()}const f=l({attributes:{position:[[-1,1],[-1,-1],[1,1],[1,-1]]},elements:[[0,1,2],[2,1,3]],uniforms:{view:()=>s([],m.eye,m.center,[0,1,0]),projection:({drawingBufferWidth:n,drawingBufferHeight:e})=>{const o=n/e;return a([],Math.PI/6,o,.01,100)},eye:()=>m.eye,center:()=>m.center,resolution:({drawingBufferWidth:n,drawingBufferHeight:e})=>[n,e],time:l.context("time")}}),p={quilt:l({frag:"precision mediump float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform float seed;\n\nvoid main() {\n    vec2 coord = gl_FragCoord.xy / resolution;\n\n    // Output RGB color in range from 0.0 to 1.0\n    vec3 color = vec3(coord.x, coord.y, 0.0);\n    color.z += abs(sin(time));\n\n    // 1. Uncomment these lines to draw triangles\n    // vec2 squareCoord = 20.0 * gl_FragCoord.xy / resolution.y + vec2(time);\n    // vec2 loc = fract(squareCoord);\n    // color = vec3(smoothstep(-0.05, 0.05, loc.y - loc.x));\n\n    // 2. Uncomment these lines to invert some of the triangles\n    // vec2 cell = squareCoord - loc;\n    // if (mod(2.0 * cell.x + cell.y, 5.0) == 1.0) {\n    //     color = 1.0 - color;\n    // }\n\n    // 3. Uncomment these lines to produce interesting colors\n    // float c = mod(3.0 * cell.x + 2.0 * cell.y, 7.0) / 7.0;\n    // color = 1.0 - (1.0 - color) * vec3(c, c, c);\n\n    // 4. Uncomment to lighten the colors\n    // color = sqrt(color);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n",vert:"attribute vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n",uniforms:{seed:()=>d.seed}}),landscape:l({frag:'precision mediump float;\n\nuniform vec2 resolution;\nuniform float time;\nuniform float seed;\nuniform float scale;\n\nfloat snoise(vec2);\n\nvoid main() {\n    vec2 coord = (2.0 * gl_FragCoord.xy - resolution) / resolution.y;\n    coord *= scale;\n\n    // "Organic" simplex noise values in range [-1, 1]\n    float noise1 = snoise(vec2(seed * 10000.0, 0) + coord);\n    float noise2 = snoise(vec2(seed * 10000.0, 1e3) + coord / 2.0);\n    float noise4 = snoise(vec2(seed * 10000.0, 2e3) + coord / 4.0);\n    float noise8 = snoise(vec2(seed * 10000.0, 3e3) + coord / 8.0);\n\n    // Display various scales of simplex noise\n    vec3 color = 0.5 + 0.5 * vec3(noise1, noise2, noise8);\n\n    // 1. Fractal noise scales: uncomment each line, one at a time\n    // color = vec3(0.5);\n    // color += 0.5 * noise8;\n    // color += 0.25 * noise4;\n    // color += 0.1 * noise2;\n    // color += 0.05 * noise1;\n\n    // 2. Generate "water" and "land"\n    // float elevation = 0.3 - 0.2 * max(length(coord) - 20.0, 0.0);\n    // elevation += noise8 + noise4 * 0.2 + noise2 * 0.1 + noise1 * 0.05;\n    // float landFactor = smoothstep(-0.05, 0.05, elevation);\n    // float deepSea = smoothstep(-0.1, -0.3, elevation);\n    // float deepColor = 0.8 - 0.3 * smoothstep(-0.2, -0.5, elevation);\n    // vec3 waterColor = mix(vec3(0.2, 0.2, 0.8), vec3(0.0, 0.0, deepColor), deepSea);\n    // color = mix(waterColor, vec3(0.0, 0.6, 0.0), landFactor);\n\n    // 3. Generate "mountains" and "beaches" based on elevation\n    // float mountainFactor = (elevation - 1.0) * 5.0;\n    // vec3 mountainColor = vec3(0.12, 0.15, 0.1);\n    // mountainColor = mix(mountainColor, vec3(0.4, 0.32, 0.4), smoothstep(0.7, 0.8, mountainFactor));\n    // mountainColor = mix(mountainColor, vec3(0.9, 0.9, 0.9), smoothstep(1.1, 1.15, mountainFactor));\n    // vec3 landColor = mix(vec3(0.0, 0.6, 0.0), mountainColor, smoothstep(0.0, 0.1, mountainFactor));\n    // float grassFactor = smoothstep(0.75, 0.7, elevation);\n    // landColor = mix(landColor, vec3(0.2, 0.8, 0.0), grassFactor);\n    // float beachFactor = smoothstep(0.5, 0.4, elevation);\n    // landColor = mix(landColor, vec3(0.9, 0.9, 0.5), beachFactor);\n    // color = mix(waterColor, landColor, landFactor);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n\n\n\n//\n// Everything below this line is an implementation of 2D simplex\n// noise in GLSL. You shouldn\'t modify any code below.\n//\n// If you\'re curious, see the following paper:\n// https://weber.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\n//\n\n// Some useful functions\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    return 130.0 * dot(m, g);\n}\n',vert:"attribute vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n",uniforms:{seed:()=>d.seed,scale:()=>d.scale}}),shading:l({attributes:{position:()=>v.vertices,normal:()=>v.normals},uniforms:{kd:()=>[d.kd.r/255,d.kd.g/255,d.kd.b/255],ks:()=>[d.ks.r/255,d.ks.g/255,d.ks.b/255],shininess:()=>d.shininess},elements:()=>v.elements,frag:"precision mediump float;\n\nuniform vec3 kd; // diffuse coefficient\nuniform vec3 ks; // specular coefficient\nuniform float shininess; // shininess parameter\nuniform vec3 eye; // position of camera\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvec3 illuminate(vec3 lightPosition) {\n    vec3 wi = lightPosition - vPosition;\n    float intensity = 1.0 / dot(wi, wi); // inverse-square law\n    vec3 diffuse = kd * max(dot(normalize(wi), normalize(vNormal)), 0.0);\n\n    // 1. Your specular highlights code goes here!\n    //\n    // This is the outline of what your program should do:\n    //  - Compute the unit vector wo from the current position to the\n    //    camera, by subtracting vPosition from eye and calling\n    //    normalize().\n    //  - Compute the reflected incident light vector r, by reflecting\n    //    normalize(wi) about normalize(vNormal) using the reflect()\n    //    function.\n    //  - Take the dot product of r and wo, then raise this to the\n    //    exponent of the shininess coefficient. (Make sure your\n    //    result is not negative!)\n    //  - Multiply the result by specular coefficient ks.\n\n    vec3 specular = vec3(0.0); // Change me!\n\n    return intensity * (diffuse + specular);\n}\n\nvoid main() {\n    // We add two lights to the scene. Feel free to change these\n    // values, or add more lights at different positions!\n    vec3 color = vec3(0.0);\n    color += 40.0 * illuminate(vec3(0.0, 3.0, 9.0));\n    color += 20.0 * illuminate(vec3(0.0, 10.0, 2.0));\n    gl_FragColor = vec4(color, 1.0);\n}\n",vert:"attribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n    vPosition = position;\n    vNormal = normal;\n    gl_Position = projection * view * vec4(position, 1.0);\n}\n"}),contours:l({attributes:{position:()=>v.vertices,normal:()=>v.normals},uniforms:{kd:()=>[d.kd.r/255,d.kd.g/255,d.kd.b/255],ks:()=>[d.ks.r/255,d.ks.g/255,d.ks.b/255],shininess:()=>d.shininess},elements:()=>v.elements,frag:"#extension GL_OES_standard_derivatives : enable\nprecision mediump float;\n\nuniform vec3 kd; // diffuse coefficient\nuniform vec3 ks; // specular coefficient\nuniform float shininess; // shininess parameter\nuniform vec3 eye; // position of camera\nuniform vec2 resolution;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvec3 illuminate(vec3 lightPosition) {\n    vec3 wi = lightPosition - vPosition;\n    float intensity = 1.0 / dot(wi, wi); // inverse-square law\n    vec3 diffuse = kd * max(dot(normalize(wi), normalize(vNormal)), 0.0);\n\n    vec3 specular = vec3(0.0); // Change me!\n\n    return intensity * (diffuse + specular);\n}\n\nvoid main() {\n    vec2 coord = gl_FragCoord.xy / resolution.y;\n\n    // We add two lights to the scene. Feel free to change these\n    // values, or add more lights at different positions!\n    vec3 color = vec3(0.0);\n    color += 40.0 * illuminate(vec3(0.0, 3.0, 9.0));\n    color += 20.0 * illuminate(vec3(0.0, 10.0, 2.0));\n\n    // Stylized shading\n    float value = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n    color = vec3(0.0);\n    vec3 darkblue = vec3(0.2, 0.3, 0.4);\n    vec3 blue = vec3(0.5, 0.65, 0.8);\n    vec3 dots = length(fract(coord * 80.0) - 0.5) < sqrt(0.5 - value) ? blue : vec3(1.0);\n    color = mix(color, darkblue, step(0.2, value));\n    color = mix(color, blue, step(0.25, value));\n    color = mix(color, dots, step(0.35, value));\n    color = mix(color, vec3(1.0), step(0.45, value));\n\n    // Edge estimation\n    float vn = abs(dot(normalize(vNormal), normalize(vPosition - eye)));\n    float vnGradient = fwidth(vn);\n    float edgeFactor = smoothstep(1.25, 0.75, vn / vnGradient / 5.0);\n    color = mix(color, vec3(0.1), edgeFactor);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n",vert:"attribute vec3 position;\nattribute vec3 normal;\n\nuniform mat4 view;\nuniform mat4 projection;\n\nvarying vec3 vPosition;\nvarying vec3 vNormal;\n\nvoid main() {\n    vPosition = position;\n    vNormal = normal;\n    gl_Position = projection * view * vec4(position, 1.0);\n}\n"}),raytracing:l({frag:"precision mediump float;\n\nuniform vec2 resolution;\nuniform float time;\n\nvoid main() {\n    vec2 coord = gl_FragCoord.xy / resolution;\n\n    // Output RGB color in range from 0.0 to 1.0\n    vec3 color = vec3(coord.x, coord.y, 0.0);\n    color.z += abs(sin(time));\n\n    gl_FragColor = vec4(color, 1.0);\n}\n",vert:"attribute vec2 position;\n\nvoid main() {\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n"})};u(d.mesh).then((()=>{const n=[...Array(60)].fill(0);l.frame((()=>{const e=n.shift(),o=performance.now();n.push(o),0!==e&&(d.fps=1e3/((o-e)/n.length)),f((()=>{"contours"===d.project?l.clear({color:[1,1,1,1]}):l.clear({color:[0,0,0,1]}),p[d.project](),performance.now()}))}))}));
